<?R
	source("conf.R") 
	c_header();
	
	source("lib/feq.R")
	source("lib/boundary.R")

	U = as.matrix(Density[Density$group=='f',c("dx","dy")])

	EQ = MRT_eq(U, ortogonal=FALSE)
        wi = subst(EQ$Req, Jx=0, Jy=0, Jz=0)
        wi = subst(wi, rho=1)
        wi = gapply(wi,function(x) x$.M, simplify=TRUE)
        wi = wi %*% solve(EQ$mat)
	wi = as.vector(wi)

	W = solve(EQ$mat) %*% diag(1/wi) %*% solve(t(EQ$mat))
	i = rev(1:nrow(W))
	H = chol(W[i,i])[i,i]
	H = H * c(1,sqrt(3)/3,sqrt(3)/3,sqrt(2),sqrt(2),1,sqrt(6)/3,sqrt(6)/3,2)
	B = EQ$mat %*% t(H)

	EQ = MRT_eq(U, mat=B)

	

	f = PV(Density[Density$group=='f',"name"])
	rho = PV("rho")
	J = PV("J",c("x","y"))
    if ( Options$BC ) {
        BC_Velocity=PV(c('BC[0]', 'BC[1]'))
    } else {
        BC_Velocity=PV(c('VelocityX', 'VelocityY'))
    }
    Grav = PV("Gravitation",c("X","Y"))

    tn = diag(c(4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36))
    c_squ = 1/3
    bounce = c(0,3,4,1,2,7,8,5,6)

	usq = PV("usq")
	u = PV(paste("u[",1:2-1,"]",sep=""))
	d = PV("d")
	RelaxationRate = PV("RelaxationRate")
?>

#define pi 3.141592653589793116

CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?> ;
}
    
CudaDeviceFunction vector_t getU(){
	vector_t u;
	u.x = ux;
	u.y = uy;
	u.z = 0.0;
	return u;
}

CudaDeviceFunction vector_t getThread(){
	vector_t ret;
	ret.x = thx;
	ret.y = thy;
	ret.z = thz;
	return ret;
}


CudaDeviceFunction real_t getSolid(){
	return sol;
}

CudaDeviceFunction real_t getChecks(){
	real_t ret = 0;
	for (ParticleIterator p(X,Y,Z); p; ++p) ret++;
	return ret;
}

CudaDeviceFunction void CalcU(){
RunBoundary();
real_t d = <?R C(sum(f)) ?>;
<?R C(PV(c("ux","uy")), (f %*% U) ) ?>
sol = 0;
}

CudaDeviceFunction void CalcF(){
	real_t fx=0, fy=0;
	sol = 0;
	real_t coverage = 0;
	for (ParticleIterator p(X,Y,Z); p; ++p) if ((p.dist - p.rad)<1) {
		sol += 1;
		
		if ((p.dist - p.rad) < - 1){
			coverage = 1;
		}else{
			coverage = (p.rad -  0.042/p.rad + 0.5 - p.dist);
		} // else >1 coverage + 0 -> not needed
		
	//	sol += coverage;

		fx += ux - p.cvel.x;
		fy += uy - p.cvel.y;
	}
	CudaSyncThreads();

	if (sol>0){
		fx /= sol;
		fy /= sol;
		ux = ux-fx;
		uy = uy-fy;
	}
		
	for (SyncParticleIterator p(X,Y,Z); p; ++p) {
		vector_t f;
		f.x=0.0; f.y=0; f.z=0;
		if (p.in()) {
			f.x = fx/sol;
			f.y = fy/sol;
			f.z = 0;
		}
		p.applyForce(f);
	}	
}

CudaDeviceFunction void CalcFandBGK(){
	real_t feqP[9], omegaS[9], uP[2], uPsq;
	real_t fx=0, fy=0;
	sol = 0;
	real_t coverage = 0;
	real_t numP = 0;
	
	real_t u[2], feq[9], usq;

	real_t d = getRho();

	uP[0] = 0;
	uP[1] = 0;

	for (ParticleIterator p(X,Y,Z); p; ++p) if ((p.dist - p.rad)<1) {
		numP += 1.0;
		
		if ((p.dist - p.rad) < - 1){
			coverage = 1.0;
		} else{
			coverage = (p.rad -  0.042/p.rad + 0.5 - p.dist);
		}
		
		if (coverage > 1.0){ coverage =  1.0;}
		if (coverage < 0.0){ coverage =  0.0;}

		sol += coverage;	
					
		uP[0] = ((numP - 1.0)*uP[0] + p.cvel.x)/numP;
		uP[1] = ((numP - 1.0)*uP[1] + p.cvel.y)/numP;
	}
	
	if (sol > 1.0){ sol =  1.0;}
	if (sol < 0.0){ sol = 0.0;}
	
	//if (sol > 0){
	//	printf("X = %d, Y = %d, uP = (%f, %f) sol = %f  u = (%f, %f) \n", X,Y,uP[0], uP[1], sol, ux, uy);
	//}	

	CudaSyncThreads();

	u[0] = ux;
        u[1] = uy;

<?R		
	feq = PV(paste("feq[",1:9-1,"]",sep=""))
	omegaS = PV(paste("omegaS[",1:9-1,"]",sep=""))
	feqP = PV(paste("feqP[",1:9-1,"]",sep=""))
	uP = PV(paste("uP[",1:2 - 1,"]",sep=""))
  	sol = PV("sol")
 	uPsq = PV("uPsq")	
	C(usq, sum(u*u)*(1/c_squ))
	C(uPsq, sum(uP*uP)*(1/c_squ))
	
	omegaF = PV("omegaF")

	for (i in 1:9){
		C(feq[i], (((u %*% t(U) *(1/c_squ))[i]) + (((u %*% t(U) * (1/c_squ))[i])*((u %*% t(U) * (1/c_squ))[i]) + usq*(-1))*0.5 + 1)*d*tn[i,i])
	}

	for (i in 1:9){
		C(feqP[i], (((uP %*% t(U) *(1/c_squ))[i]) + (((uP %*% t(U) * (1/c_squ))[i])*((uP %*% t(U) * (1/c_squ))[i]) + uPsq*(-1))*0.5 + 1)*d*tn[i,i])
	}
	for (i in 1:9){
		C(omegaS[i],  f[bounce[i]+1] - f[i] + feqP[i] - feq[bounce[i] + 1])
	}
	
	for (i in 1:9){
		C(f[i], f[i] + (1.0-sol)*omegaF*(feq[i] - f[i]) + sol*omegaS[i])
	}

?>
	for (SyncParticleIterator p(X,Y,Z); p; ++p) {
		vector_t force;
		force.x=0.0; force.y=0.0; force.z=0.0;
		if (sol>0) {
			force.x = -sol * ( <?R C(t(U[,1] %*% omegaS)) ?> );
			force.y = -sol * ( <?R C(t(U[,2] %*% omegaS)) ?> );
			force.z = 0.0;
		}
		p.applyForce(force);
	}
}



CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
/*        ret.y = 1;
        ret.x = 0;
	for (TreeParticleIterator p(X,Y,Z); p; ++p) {
		ret.x += 0.01;
		if (p.in()) {
			ret.y = 0;
		}
	}*/
        ret.x = sqrt(u.x*u.x + u.y*u.y);
        ret.y = 1-sol;
        return ret;
}

CudaDeviceFunction void SetEquilibrum(real_t rho, real_t Jx, real_t Jy)
{
<?R
	feq = EQ$Req %*% solve(EQ$mat)
	C( f, feq)
?>

<?R if ( Options$BC ) { ?>
   if ( IamBOUNDARY ) {
       BC[0] = Jx / rho;
       BC[1] = Jy / rho;
   } else {
       BC[0] = 0;
       BC[1] = 0;
   }
<?R } ?>
}

CudaDeviceFunction void Init() {
	real_t rho;
   	rho = (1+Pressure*3);
	ux = VelocityX;
    uy = VelocityY;
    if (IamWall){
        rho = 1;
        ux = 0;
        uy = 0;
    }
	SetEquilibrum(
		rho,
		ux*rho,
		uy*rho
	);
}



CudaDeviceFunction void RunBoundary() {
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Solid:
	case NODE_Wall:
		BounceBack();
		break;
	case NODE_EVelocity:
		EVelocity();
		break;
	case NODE_WPressure:
		WPressure();
		break;
	case NODE_WVelocity:
		WVelocity();
		break;
	case NODE_EPressure:
		EPressure();
		break;
	case NODE_NVelocity:
		NVelocity();
		break;
	case NODE_SVelocity:
		SVelocity();
		break;
    case NODE_NSymmetry:
        NSymmetry();
        break;
    case NODE_SSymmetry:
        SSymmetry();
        break;
    }
}

CudaDeviceFunction void Run() {
thx = CudaThread.x;
thy = CudaThread.y;
thz = CudaThread.z;
	RunBoundary();
	real_t d = <?R C(sum(f)) ?>;
	<?R C(PV(c("ux","uy")), (f %*% U) * PV("d")^ (-1) + Grav * 0.5 ) ?>
	sol = 0;

	
	//CalcF();
        if (NodeType & NODE_MRT)
        {       
                CalcF(); //was outside bracket for original version, incorporated with BGK in JM
        	CollisionMRT();
        } else if (NodeType & NODE_BGK){
		CalcFandBGK();
	}
}

CudaDeviceFunction void BounceBack()
{
<?R
	if ( Options$BC ) {
		C(PV('real_t temp'), sum(f))
?>
    if ( temp !=  1+Pressure*3 ) {
        <?R C(PV(c('BC[0]', 'BC[1]')), 2.* f %*% U); ?>
    } else {
        <?R C(PV(c('BC[0]', 'BC[1]')), c(0,0) ); ?>
    }
<?R
	}
	FullBounceBack()
?>
}

CudaDeviceFunction void EVelocity()
{
<?R ZouHeRewrite(EQ, f, c(1, 0), "velocity", BC_Velocity) ?>
}

CudaDeviceFunction void WPressure()
{
<?R ZouHeRewrite(EQ, f, c(-1, 0), "pressure") ?>
}

CudaDeviceFunction void WVelocity()
{
<?R ZouHeRewrite(EQ, f, c(-1, 0), "velocity", BC_Velocity) ?>
}

CudaDeviceFunction void EPressure()
{
<?R ZouHeRewrite(EQ, f, c(1, 0), "pressure") ?>
}

CudaDeviceFunction void NVelocity()
{
<?R ZouHeRewrite(EQ, f, c(0,1), "velocity", BC_Velocity) ?>
}

CudaDeviceFunction void SVelocity()
{
<?R ZouHeRewrite(EQ, f, c(0, -1), "velocity", BC_Velocity) ?>
}

CudaDeviceFunction void NSymmetry()
{
<?R Symmetry(2,-1,'f') ?>
}

CudaDeviceFunction void SSymmetry()
{
<?R Symmetry(2,1,'f') ?>
}


CudaDeviceFunction void CollisionBGK(){
	real_t u[2], d, feq[9], usq;

	d = getRho();
<?R 	
	C(PV(c("u[0]","u[1]")), f %*% U)

	feq = PV(paste("feq[",1:9-1,"]",sep=""))
	omegaF = PV("omegaF")
?>
	
<?R	if (Options$BC) { ?>
		if (!IamBOUNDARY) {
			u[0] = u[0] + d*(GravitationX + BC[0]);
			u[1] = u[1] + d*(GravitationX + BC[1]);
		}
<?R	} else { ?>
		u[0] = ux + d*(GravitationX);
		u[1] = uy + d*(GravitationX);
<?R	}	?>
	
<?R	
	C(usq, sum(u*u)*(1/c_squ))
	
	for (i in 1:9){
		C(feq[i], (((u %*% t(U) *(1/c_squ))[i]) + (((u %*% t(U) * (1/c_squ))[i])*((u %*% t(U) * (1/c_squ))[i]) + usq*(-1))*0.5 + 1)*d*tn[i,i])
	}

	for (i in 1:9){
		C(f[i], f[i] + omegaF*(feq[i] - f[i]))
	}

?>


}

CudaDeviceFunction void CollisionMRT()
{

<?R
	MI = solve(EQ$mat)
	P = MI %*% diag(1/wi) %*% t(MI)

	R = PV("R", 1:nrow(U)-1);
	selR = EQ$order > 1
	R[!selR] = EQ$Req[!selR]
?>


 
	real_t <?R C(R,sep=",") ?>;
    real_t Usq=0;

<?R
    S=PV("S",1:nrow(U)-1);
	S[EQ$order == 2] = PV("S2")
	S[EQ$order == 3] = PV("S3")
 	S[EQ$order == 4] = PV("S4")   
	C( R, f %*% EQ$mat );

?>

    switch (NodeType & NODE_OBJECTIVE) {
        case NODE_Outlet:
<?R 
            Usq=PV('Usq')
            C(Usq,sum(J%*%J) * rho ^-2)

?>
            AddToOutletFlux(Jx/rho/rho);
            AddToPressureLoss(-(Jx/rho)/rho*((rho-1.)/3. + Usq/rho/2.));
        break;
        case NODE_Inlet:
<?R
            Usq=PV('Usq')
            C(Usq,sum(J%*%J) * rho ^-2)
?>
           AddToInletFlux(Jx/rho/rho);
           AddToPressureLoss((Jx/rho)/rho*((rho-1.)/3. + Usq/rho/2.));
       break;
    }

<?R
	C( R[selR], (R - EQ$Req)[selR]);
	C( R[selR], (R * S)[selR]);

?>

<?R if ( Options$BC ) { ?>
    if (!IamBOUNDARY) {
        Jx = Jx + (GravitationX +  BC[0])*rho ;
        Jy = Jy + (GravitationY +  BC[1])*rho ; 
    }
<?R } else { ?>
	Jx = Jx + ((ux + GravitationX*0.5)*rho - Jx);
	Jy = Jy + ((uy + GravitationY*0.5)*rho - Jy);
<?R } ?>

<?R
    C( R[selR], (R + EQ$Req)[selR]);
	C( f, R %*% solve(EQ$mat), float=F);
?>
}

CudaDeviceFunction void CollisionBGK2()
{

<?R
	MI = solve(EQ$mat)
	P = MI %*% diag(1/wi) %*% t(MI)

	R = PV("R", 1:nrow(U)-1);
	selR = EQ$order > 1
	R[!selR] = EQ$Req[!selR]
?>


 
	real_t <?R C(R,sep=",") ?>;
    real_t Usq=0;

<?R
    S=PV("S",1:nrow(U)-1);
	S[EQ$order == 2] = PV("S2")
	S[EQ$order == 3] = PV("S3")
 	S[EQ$order == 4] = PV("S4")   
	C( R, f %*% EQ$mat );

?>

    switch (NodeType & NODE_OBJECTIVE) {
        case NODE_Outlet:
<?R 
            Usq=PV('Usq')
            C(Usq,sum(J%*%J) * rho ^-2)

?>
            AddToOutletFlux(Jx/rho/rho);
            AddToPressureLoss(-(Jx/rho)/rho*((rho-1.)/3. + Usq/rho/2.));
        break;
        case NODE_Inlet:
<?R
            Usq=PV('Usq')
            C(Usq,sum(J%*%J) * rho ^-2)
?>
           AddToInletFlux(Jx/rho/rho);
           AddToPressureLoss((Jx/rho)/rho*((rho-1.)/3. + Usq/rho/2.));
       break;
    }

<?R
	C( R[selR], (R - EQ$Req)[selR]);
	C( R[selR], (R * S)[selR]);

?>

<?R if ( Options$BC ) { ?>
    if (!IamBOUNDARY) {
        Jx = Jx + (GravitationX +  BC[0])*rho ;
        Jy = Jy + (GravitationY +  BC[1])*rho ; 
    }
<?R } else { ?>
	Jx = Jx + ((ux + GravitationX*0.5)*rho - Jx);
	Jy = Jy + ((uy + GravitationY*0.5)*rho - Jy);
<?R } ?>

	real_t u[2], d, feq[9], usq;
<?R
        C( R[selR], (R + EQ$Req)[selR]);

	C(PV(c("u[0]","u[1]")), J)

	feq = PV(paste("feq[",1:9-1,"]",sep=""))
	omegaF = PV("omegaF")

	C(usq, sum(u*u)*(1/c_squ)) 
	for (i in 1:9){
		C(feq[i], (((u %*% t(U) *(1/c_squ))[i]) + (((u %*% t(U) * (1/c_squ))[i])*((u %*% t(U) * (1/c_squ))[i]) + usq*(-1))*0.5 + 1)*rho*tn[i,i])
	}

	for (i in 1:9){
		C(f[i], f[i] + omegaF*(feq[i] - f[i]))
	}


?>


}

